import { APIClient, FetchProvider, Serializer, Action, PermissionLevel, SignedTransaction, Transaction, Struct, Checksum256, Name } from '@wharfkit/antelope';
export * from '@wharfkit/antelope';
import { ChainDefinition, Logo } from '@wharfkit/common';
export * from '@wharfkit/common';
import zlib from 'pako';
import { RequestDataV2, RequestDataV3, RequestSignature, SigningRequest, ResolvedSigningRequest, ChainId } from '@wharfkit/signing-request';
export * from '@wharfkit/signing-request';
import { ABICache } from '@wharfkit/abicache';
export * from '@wharfkit/abicache';
import { __decorate } from 'tslib';

var LoginHookTypes;
(function (LoginHookTypes) {
    LoginHookTypes["beforeLogin"] = "beforeLogin";
    LoginHookTypes["afterLogin"] = "afterLogin";
})(LoginHookTypes || (LoginHookTypes = {}));
class LoginContext {
    constructor(options) {
        this.chains = [];
        this.hooks = {
            afterLogin: [],
            beforeLogin: [],
        };
        this.uiRequirements = {
            requiresChainSelect: true,
            requiresPermissionSelect: true,
            requiresPermissionEntry: false,
            requiresWalletSelect: true,
        };
        this.walletPlugins = [];
        this.appName = String(options.appName);
        if (options.chains) {
            this.chains = options.chains;
        }
        if (options.chain) {
            this.chain = options.chain;
        }
        this.fetch = options.fetch;
        this.permissionLevel = options.permissionLevel;
        this.walletPlugins = options.walletPlugins || [];
        this.ui = options.ui;
        options.loginPlugins?.forEach((plugin) => {
            plugin.register(this);
        });
    }
    addHook(t, hook) {
        this.hooks[t].push(hook);
    }
    getClient(chain) {
        return new APIClient({ provider: new FetchProvider(chain.url, { fetch: this.fetch }) });
    }
    get esrOptions() {
        return {
            zlib,
        };
    }
}
class AbstractLoginPlugin {
}
class BaseLoginPlugin extends AbstractLoginPlugin {
    register() {
    }
}

var TransactHookTypes;
(function (TransactHookTypes) {
    TransactHookTypes["beforeSign"] = "beforeSign";
    TransactHookTypes["afterSign"] = "afterSign";
    TransactHookTypes["afterBroadcast"] = "afterBroadcast";
})(TransactHookTypes || (TransactHookTypes = {}));
class TransactContext {
    constructor(options) {
        this.hooks = {
            afterBroadcast: [],
            afterSign: [],
            beforeSign: [],
        };
        this.abiCache = options.abiCache;
        this.appName = String(options.appName);
        this.chain = options.chain;
        this.client = options.client;
        this.createRequest = options.createRequest;
        this.fetch = options.fetch;
        this.permissionLevel = options.permissionLevel;
        if (options.storage) {
            this.storage = options.storage;
        }
        this.transactPluginsOptions = options.transactPluginsOptions || {};
        this.ui = options.ui;
        options.transactPlugins?.forEach((plugin) => {
            plugin.register(this);
        });
    }
    get accountName() {
        return this.permissionLevel.actor;
    }
    get permissionName() {
        return this.permissionLevel.permission;
    }
    get esrOptions() {
        return {
            abiProvider: this.abiCache,
            zlib,
        };
    }
    addHook(t, hook) {
        switch (t) {
            case TransactHookTypes.beforeSign: {
                this.hooks[t].push(hook);
                break;
            }
            case TransactHookTypes.afterSign:
            case TransactHookTypes.afterBroadcast: {
                this.hooks[t].push(hook);
                break;
            }
        }
    }
    async getInfo() {
        let info = this.info;
        if (this.info) {
            info = this.info;
        }
        else {
            this.info = info = await this.client.v1.chain.get_info();
        }
        return info;
    }
    async resolve(request, expireSeconds = 120) {
        let resolveArgs = {
            chainId: this.chain.id,
        };
        if (request.requiresTapos()) {
            const info = await this.getInfo();
            const header = info.getTransactionHeader(expireSeconds);
            resolveArgs = {
                ...resolveArgs,
                ...header,
            };
        }
        const abis = await request.fetchAbis(this.abiCache);
        return request.resolve(abis, this.permissionLevel, resolveArgs);
    }
}
class TransactRevisions {
    constructor(request) {
        this.revisions = [];
        this.addRevision({ request, signatures: [] }, 'original', true);
    }
    addRevision(response, code, allowModify) {
        let modified = false;
        const previous = this.revisions[this.revisions.length - 1];
        if (previous) {
            modified = previous.response.request !== String(response.request);
        }
        this.revisions.push({
            allowModify,
            code: String(code),
            modified,
            response: {
                request: String(response.request),
                signatures: response.signatures ? Serializer.objectify(response.signatures) : [],
            },
        });
    }
}
class AbstractTransactPlugin {
}
class BaseTransactPlugin extends AbstractTransactPlugin {
    get id() {
        return 'base-transact-plugin';
    }
    register() {
    }
}

function getFetch(options) {
    if (options && options.fetch) {
        return options.fetch;
    }
    if (typeof window !== 'undefined' && window.fetch) {
        return window.fetch.bind(window);
    }
    if (typeof global !== 'undefined' && global.fetch) {
        return global.fetch.bind(global);
    }
    throw new Error('Missing fetch');
}
function appendAction(request, action) {
    const newAction = Action.from(action);
    const cloned = request.clone();
    switch (cloned.data.req.variantName) {
        case 'action': {
            cloned.data.req.value = [cloned.data.req.value, newAction];
            cloned.data.req.variantIdx = 1;
            break;
        }
        case 'action[]': {
            const array = cloned.data.req.value;
            array.push(newAction);
            cloned.data.req.value = array;
            break;
        }
        case 'transaction': {
            const tx = cloned.data.req.value;
            tx.actions.push(newAction);
            cloned.data.req.value = tx;
            break;
        }
        default: {
            throw new Error('unknown data req type');
        }
    }
    return cloned;
}
function prependAction(request, action) {
    const newAction = Action.from(action);
    const cloned = request.clone();
    switch (cloned.data.req.variantName) {
        case 'action': {
            cloned.data.req.value = [newAction, cloned.data.req.value];
            cloned.data.req.variantIdx = 1;
            break;
        }
        case 'action[]': {
            const array = cloned.data.req.value;
            array.unshift(newAction);
            cloned.data.req.value = array;
            break;
        }
        case 'transaction': {
            const tx = cloned.data.req.value;
            tx.actions.unshift(newAction);
            cloned.data.req.value = tx;
            break;
        }
        default: {
            throw new Error('unknown data req type');
        }
    }
    return cloned;
}

class Session {
    constructor(args, options = {}) {
        this.abis = [];
        this.allowModify = true;
        this.broadcast = true;
        this.expireSeconds = 120;
        this.transactPluginsOptions = {};
        this.serialize = () => Serializer.objectify({
            chain: this.chain.id,
            actor: this.permissionLevel.actor,
            permission: this.permissionLevel.permission,
            walletPlugin: this.walletPlugin.serialize(),
        });
        this.chain = ChainDefinition.from(args.chain);
        if (args.permissionLevel) {
            this.permissionLevel = PermissionLevel.from(args.permissionLevel);
        }
        else if (args.actor && args.permission) {
            this.permissionLevel = PermissionLevel.from(`${args.actor}@${args.permission}`);
        }
        else {
            throw new Error('Either a permissionLevel or actor/permission must be provided when creating a new Session.');
        }
        this.walletPlugin = args.walletPlugin;
        if (options.appName) {
            this.appName = String(options.appName);
        }
        if (options.abis) {
            this.abis = [...options.abis];
        }
        if (options.allowModify !== undefined) {
            this.allowModify = options.allowModify;
        }
        if (options.broadcast !== undefined) {
            this.broadcast = options.broadcast;
        }
        if (options.expireSeconds) {
            this.expireSeconds = options.expireSeconds;
        }
        if (options.fetch) {
            this.fetch = options.fetch;
        }
        else {
            this.fetch = getFetch(options);
        }
        if (options.storage) {
            this.storage = options.storage;
        }
        if (options.transactPlugins) {
            this.transactPlugins = options.transactPlugins;
        }
        else {
            this.transactPlugins = [new BaseTransactPlugin()];
        }
        if (options.transactPluginsOptions) {
            this.transactPluginsOptions = options.transactPluginsOptions;
        }
        if (options.abiCache) {
            this.abiCache = options.abiCache;
        }
        else {
            this.abiCache = new ABICache(this.client);
        }
        if (options.ui) {
            this.ui = options.ui;
        }
    }
    get actor() {
        return this.permissionLevel.actor;
    }
    get permission() {
        return this.permissionLevel.permission;
    }
    get client() {
        return new APIClient({ provider: new FetchProvider(this.chain.url, { fetch: this.fetch }) });
    }
    upgradeTransaction(args) {
        const anyArgs = args;
        if (args.actions &&
            (anyArgs.expiration ||
                anyArgs.ref_block_num ||
                anyArgs.ref_block_prefix ||
                anyArgs.max_net_usage_words ||
                anyArgs.max_cpu_usage_ms ||
                anyArgs.delay_sec)) {
            return (args = {
                transaction: {
                    expiration: '1970-01-01T00:00:00',
                    ref_block_num: 0,
                    ref_block_prefix: 0,
                    max_net_usage_words: 0,
                    max_cpu_usage_ms: 0,
                    delay_sec: 0,
                    ...anyArgs,
                },
            });
        }
        return args;
    }
    storageType(version) {
        return version === 2 ? RequestDataV2 : RequestDataV3;
    }
    cloneRequest(request, abiCache) {
        let signature;
        if (request.signature) {
            signature = RequestSignature.from(JSON.parse(JSON.stringify(request.signature)));
        }
        const RequestData = this.storageType(request.version);
        const data = RequestData.from(JSON.parse(JSON.stringify(request.data)));
        return new SigningRequest(request.version, data, zlib, abiCache, signature);
    }
    async createRequest(args, abiCache) {
        let request;
        const options = {
            abiProvider: abiCache,
            zlib,
        };
        if (args.request && args.request instanceof SigningRequest) {
            request = this.cloneRequest(args.request, abiCache);
        }
        else if (args.request) {
            request = SigningRequest.from(args.request, options);
        }
        else {
            args = this.upgradeTransaction(args);
            request = await SigningRequest.create({
                ...args,
                chainId: this.chain.id,
            }, options);
        }
        request.setBroadcast(false);
        return request;
    }
    async updateRequest(previous, modified, abiCache) {
        const updatedRequest = this.cloneRequest(modified, abiCache);
        const info = updatedRequest.getRawInfo();
        previous.data.info.forEach((metadata) => {
            if (info[metadata.key]) {
                console.warn(`During an updateRequest call, the previous request had already set the ` +
                    `metadata key of "${metadata.key}" which will not be overwritten.`);
            }
            updatedRequest.setRawInfoKey(metadata.key, metadata.value);
        });
        return updatedRequest;
    }
    async transact(args, options) {
        try {
            const expireSeconds = options && options.expireSeconds ? options.expireSeconds : this.expireSeconds;
            const willBroadcast = options && typeof options.broadcast !== 'undefined'
                ? options.broadcast
                : this.broadcast;
            const abiCache = options?.abiCache || this.abiCache;
            const abiDefs = [...this.abis];
            if (options?.abis) {
                abiDefs.push(...options.abis);
            }
            if (abiCache['setAbi']) {
                abiDefs.forEach((def) => abiCache['setAbi'](def.account, def.abi));
            }
            else {
                throw new Error('Custom `abiCache` does not support `setAbi` method.');
            }
            const transactPlugins = options?.transactPlugins || this.transactPlugins;
            const transactPluginsOptions = options?.transactPluginsOptions || this.transactPluginsOptions;
            let allowModify = options && typeof options.allowModify !== 'undefined'
                ? options.allowModify
                : this.allowModify;
            const context = new TransactContext({
                abiCache,
                appName: this.appName,
                chain: this.chain,
                client: this.client,
                createRequest: (args) => this.createRequest(args, abiCache),
                fetch: this.fetch,
                permissionLevel: this.permissionLevel,
                storage: this.storage,
                transactPlugins,
                transactPluginsOptions,
                ui: this.ui,
            });
            if (context.ui) {
                await context.ui.onTransact();
                for (const translation of transactPlugins.map((transactPlugin) => this.getPluginTranslations(transactPlugin))) {
                    context.ui.addTranslations(translation);
                }
            }
            let request = await this.createRequest(args, abiCache);
            const result = {
                chain: this.chain,
                request,
                resolved: undefined,
                revisions: new TransactRevisions(request),
                signatures: [],
                signer: this.permissionLevel,
                transaction: undefined,
            };
            for (const hook of context.hooks.beforeSign) {
                const response = await hook(request.clone(), context);
                if (response) {
                    result.revisions.addRevision(response, String(hook), allowModify);
                    if (allowModify) {
                        request = await this.updateRequest(request, response.request, abiCache);
                    }
                    if (response.signatures) {
                        result.signatures = [...result.signatures, ...response.signatures];
                        allowModify = false;
                    }
                }
            }
            result.request = request;
            result.resolved = await context.resolve(request, expireSeconds);
            result.transaction = result.resolved.resolvedTransaction;
            if (context.ui) {
                await context.ui.onSign();
                context.ui.addTranslations(this.getPluginTranslations(this.walletPlugin));
            }
            const walletResponse = await this.walletPlugin.sign(result.resolved, context);
            result.signatures.push(...walletResponse.signatures);
            if (walletResponse.resolved) {
                const { resolved } = walletResponse;
                const requestWasModified = !result.resolved.transaction.equals(resolved.transaction);
                if (requestWasModified) {
                    if (allowModify) {
                        result.request = resolved.request;
                        result.resolved = resolved;
                        result.transaction = resolved.resolvedTransaction;
                    }
                    else {
                        throw new Error(`The ${this.walletPlugin.metadata.name} plugin modified the transaction when it was not allowed to.`);
                    }
                }
            }
            for (const hook of context.hooks.afterSign)
                await hook(result, context);
            if (context.ui) {
                await context.ui.onSignComplete();
            }
            if (willBroadcast) {
                if (context.ui) {
                    await context.ui.onBroadcast();
                }
                const signed = SignedTransaction.from({
                    ...result.resolved.transaction,
                    signatures: result.signatures,
                });
                result.response = await context.client.v1.chain.send_transaction(signed);
                for (const hook of context.hooks.afterBroadcast)
                    await hook(result, context);
                if (context.ui) {
                    await context.ui.onBroadcastComplete();
                }
            }
            if (context.ui) {
                await context.ui.onTransactComplete();
            }
            return result;
        }
        catch (error) {
            if (error.response && error.response.json) {
                const { json } = error.response;
                if (json.error && json.error.details) {
                    const e = new Error(json.error.details[0].message);
                    if (this.ui) {
                        await this.ui.onError(e);
                    }
                    throw e;
                }
            }
            else {
                if (this.ui) {
                    await this.ui.onError(error);
                }
            }
            throw new Error(error);
        }
    }
    async signTransaction(transaction) {
        const context = new TransactContext({
            abiCache: this.abiCache,
            chain: this.chain,
            client: this.client,
            createRequest: (args) => this.createRequest(args, this.abiCache),
            fetch: this.fetch,
            permissionLevel: this.permissionLevel,
        });
        const request = await SigningRequest.create({
            transaction,
            chainId: this.chain.id,
        }, context.esrOptions);
        request.setBroadcast(false);
        const resolvedRequest = new ResolvedSigningRequest(request, this.permissionLevel, Transaction.from(transaction), Serializer.objectify(Transaction.from(transaction)), ChainId.from(this.chain.id));
        const walletResponse = await this.walletPlugin.sign(resolvedRequest, context);
        return walletResponse.signatures;
    }
    getPluginTranslations(transactPlugin) {
        if (!transactPlugin.translations) {
            return {};
        }
        const prefixed = {};
        const languages = Object.keys(transactPlugin.translations);
        languages.forEach((lang) => {
            if (transactPlugin.translations) {
                prefixed[lang] = { [transactPlugin.id]: transactPlugin.translations[lang] };
            }
        });
        return prefixed;
    }
}

class BrowserLocalStorage {
    constructor(keyPrefix = '') {
        this.keyPrefix = keyPrefix;
    }
    async write(key, data) {
        localStorage.setItem(this.storageKey(key), data);
    }
    async read(key) {
        return localStorage.getItem(this.storageKey(key));
    }
    async remove(key) {
        localStorage.removeItem(this.storageKey(key));
    }
    storageKey(key) {
        return `wharf-${this.keyPrefix}-${key}`;
    }
}

var WalletPluginMetadata_1;
let WalletPluginMetadata = WalletPluginMetadata_1 = class WalletPluginMetadata extends Struct {
    static from(data) {
        return new WalletPluginMetadata_1({
            ...data,
            logo: data.logo ? Logo.from(data.logo) : undefined,
        });
    }
};
__decorate([
    Struct.field('string', { optional: true })
], WalletPluginMetadata.prototype, "name", void 0);
__decorate([
    Struct.field('string', { optional: true })
], WalletPluginMetadata.prototype, "description", void 0);
__decorate([
    Struct.field(Logo, { optional: true })
], WalletPluginMetadata.prototype, "logo", void 0);
__decorate([
    Struct.field('string', { optional: true })
], WalletPluginMetadata.prototype, "homepage", void 0);
__decorate([
    Struct.field('string', { optional: true })
], WalletPluginMetadata.prototype, "download", void 0);
__decorate([
    Struct.field('string', { optional: true })
], WalletPluginMetadata.prototype, "publicKey", void 0);
WalletPluginMetadata = WalletPluginMetadata_1 = __decorate([
    Struct.type('wallet_plugin_metadata')
], WalletPluginMetadata);
class AbstractWalletPlugin {
    constructor() {
        this._data = {};
        this.config = {
            requiresChainSelect: true,
            requiresPermissionSelect: false,
            requiresPermissionEntry: false,
        };
        this.metadata = new WalletPluginMetadata({});
    }
    get data() {
        return this._data;
    }
    set data(data) {
        this._data = data;
    }
    serialize() {
        return {
            id: this.id,
            data: this.data,
        };
    }
}

class SessionKit {
    constructor(args, options = {}) {
        this.abis = [];
        this.allowModify = true;
        this.expireSeconds = 120;
        this.transactPluginsOptions = {};
        this.appName = String(args.appName);
        this.chains = args.chains.map((chain) => ChainDefinition.from(chain));
        this.ui = args.ui;
        this.walletPlugins = args.walletPlugins;
        if (options.fetch) {
            this.fetch = options.fetch;
        }
        else {
            this.fetch = getFetch(options);
        }
        if (options.abis) {
            this.abis = [...options.abis];
        }
        if (options.loginPlugins) {
            this.loginPlugins = options.loginPlugins;
        }
        else {
            this.loginPlugins = [new BaseLoginPlugin()];
        }
        if (options.storage) {
            this.storage = options.storage;
        }
        else {
            this.storage = new BrowserLocalStorage();
        }
        if (options.transactPlugins) {
            this.transactPlugins = options.transactPlugins;
        }
        else {
            this.transactPlugins = [new BaseTransactPlugin()];
        }
        if (typeof options.allowModify !== 'undefined') {
            this.allowModify = options.allowModify;
        }
        if (options.expireSeconds) {
            this.expireSeconds = options.expireSeconds;
        }
        if (options.transactPluginsOptions) {
            this.transactPluginsOptions = options.transactPluginsOptions;
        }
    }
    getChainDefinition(id, override) {
        const chains = override ? override : this.chains;
        const chainId = Checksum256.from(id);
        const chain = chains.find((c) => c.id.equals(chainId));
        if (!chain) {
            throw new Error(`No chain defined with the ID of: ${chainId}`);
        }
        return chain;
    }
    async login(options) {
        try {
            const context = new LoginContext({
                appName: this.appName,
                chain: undefined,
                chains: options && options?.chains
                    ? options.chains.map((c) => this.getChainDefinition(c))
                    : this.chains,
                fetch: this.fetch,
                loginPlugins: this.loginPlugins,
                ui: this.ui,
                walletPlugins: this.walletPlugins.map((plugin) => {
                    return {
                        config: plugin.config,
                        metadata: WalletPluginMetadata.from(plugin.metadata),
                    };
                }),
            });
            await context.ui.onLogin();
            if (options && options.chain) {
                context.chain = this.getChainDefinition(options.chain, context.chains);
                context.uiRequirements.requiresChainSelect = false;
            }
            else if (context.chains.length === 1) {
                context.chain = context.chains[0];
                context.uiRequirements.requiresChainSelect = false;
            }
            if (options?.permissionLevel) {
                context.permissionLevel = PermissionLevel.from(options.permissionLevel);
                context.uiRequirements.requiresPermissionSelect = false;
            }
            let walletPlugin = undefined;
            if (this.walletPlugins.length === 1) {
                walletPlugin = this.walletPlugins[0];
                context.uiRequirements.requiresWalletSelect = false;
            }
            else if (options?.walletPlugin) {
                walletPlugin = this.walletPlugins.find((p) => p.id === options.walletPlugin);
                if (walletPlugin) {
                    context.uiRequirements.requiresWalletSelect = false;
                }
            }
            if (context.uiRequirements.requiresChainSelect ||
                context.uiRequirements.requiresPermissionSelect ||
                context.uiRequirements.requiresPermissionEntry ||
                context.uiRequirements.requiresWalletSelect) {
                const uiLoginResponse = await context.ui.login(context);
                if (uiLoginResponse.walletPluginIndex !== undefined) {
                    walletPlugin = this.walletPlugins[uiLoginResponse.walletPluginIndex];
                }
                if (!walletPlugin) {
                    throw new Error('UserInterface did not return a valid WalletPlugin index.');
                }
                if (uiLoginResponse.chainId) {
                    if (!context.chains.some((c) => c.id.equals(uiLoginResponse.chainId))) {
                        throw new Error('UserInterface did not return a chain ID matching the subset of chains.');
                    }
                    context.chain = this.getChainDefinition(uiLoginResponse.chainId, context.chains);
                }
                if (uiLoginResponse.permissionLevel) {
                    context.permissionLevel = PermissionLevel.from(uiLoginResponse.permissionLevel);
                }
            }
            if (!walletPlugin) {
                throw new Error('No WalletPlugin available to perform the login.');
            }
            const { supportedChains } = walletPlugin.config;
            if (context.chain &&
                supportedChains &&
                supportedChains.length &&
                !supportedChains.includes(String(context.chain.id))) {
                throw new Error(`The wallet plugin '${walletPlugin.metadata.name}' does not support the chain '${context.chain.id}'`);
            }
            for (const hook of context.hooks.beforeLogin)
                await hook(context);
            const response = await walletPlugin.login(context);
            const session = new Session({
                chain: this.getChainDefinition(response.chain),
                permissionLevel: response.permissionLevel,
                walletPlugin,
            }, this.getSessionOptions(options));
            for (const hook of context.hooks.afterLogin)
                await hook(context);
            this.persistSession(session);
            await context.ui.onLoginComplete();
            return {
                context,
                response,
                session,
            };
        }
        catch (error) {
            await this.ui.onError(error);
            throw new Error(error);
        }
    }
    async logout(session) {
        if (!this.storage) {
            throw new Error('An instance of Storage must be provided to utilize the logout method.');
        }
        await this.storage.remove('session');
        if (session) {
            const sessions = await this.getSessions();
            if (sessions) {
                let serialized = session;
                if (session instanceof Session) {
                    serialized = session.serialize();
                }
                const other = sessions.filter((s) => {
                    return (!Checksum256.from(s.chain).equals(Checksum256.from(String(serialized.chain))) ||
                        !Name.from(s.actor).equals(Name.from(serialized.actor)) ||
                        !Name.from(s.permission).equals(Name.from(serialized.permission)));
                });
                await this.storage.write('sessions', JSON.stringify(other));
            }
        }
        else {
            await this.storage.remove('sessions');
        }
    }
    async restore(args, options) {
        if (!args) {
            const data = await this.storage.read('session');
            if (data) {
                args = JSON.parse(data);
            }
            else {
                return;
            }
        }
        if (!args) {
            throw new Error('Either a RestoreArgs object or a Storage instance must be provided.');
        }
        let serializedSession;
        const data = await this.storage.read('sessions');
        if (data) {
            const sessions = JSON.parse(data);
            if (args.actor && args.permission) {
                serializedSession = sessions.find((s) => {
                    return (args &&
                        s.chain === args.chain &&
                        s.actor === args.actor &&
                        s.permission === args.permission);
                });
            }
            else {
                serializedSession = sessions.find((s) => {
                    return args && s.chain === args.chain && s.default;
                });
            }
        }
        else {
            if (args.actor && args.permission && args.walletPlugin) {
                serializedSession = {
                    chain: args.chain,
                    actor: args.actor,
                    permission: args.permission,
                    walletPlugin: {
                        id: args.walletPlugin.id,
                        data: args.walletPlugin.data,
                    },
                };
            }
            else {
                throw new Error('No sessions found in storage. A wallet plugin must be provided.');
            }
        }
        const walletPlugin = this.walletPlugins.find((p) => {
            if (!args) {
                return false;
            }
            return p.id === serializedSession.walletPlugin.id;
        });
        if (!walletPlugin) {
            throw new Error(`No WalletPlugin found with the ID of: '${serializedSession.walletPlugin.id}'`);
        }
        if (serializedSession.walletPlugin.data) {
            walletPlugin.data = serializedSession.walletPlugin.data;
        }
        if (args.walletPlugin && args.walletPlugin.data) {
            walletPlugin.data = args.walletPlugin.data;
        }
        const session = new Session({
            chain: this.getChainDefinition(serializedSession.chain),
            permissionLevel: PermissionLevel.from({
                actor: serializedSession.actor,
                permission: serializedSession.permission,
            }),
            walletPlugin,
        }, this.getSessionOptions(options));
        this.persistSession(session);
        return session;
    }
    async restoreAll() {
        const sessions = [];
        const serializedSessions = await this.getSessions();
        if (serializedSessions) {
            for (const s of serializedSessions) {
                const session = await this.restore(s);
                if (session) {
                    sessions.push(session);
                }
            }
        }
        return sessions;
    }
    async persistSession(session, setAsDefault = true) {
        if (!this.storage) {
            return;
        }
        const serialized = session.serialize();
        serialized.default = setAsDefault;
        this.storage.write('session', JSON.stringify(serialized));
        const existing = await this.storage.read('sessions');
        if (existing) {
            const stored = JSON.parse(existing);
            const sessions = stored
                .filter((s) => {
                return (!Checksum256.from(s.chain).equals(Checksum256.from(serialized.chain)) ||
                    !Name.from(s.actor).equals(Name.from(serialized.actor)) ||
                    !Name.from(s.permission).equals(Name.from(serialized.permission)));
            })
                .map((s) => {
                if (session.chain.id.equals(s.chain)) {
                    s.default = false;
                }
                return s;
            });
            const orderedSessions = [...sessions, serialized];
            orderedSessions.sort((a, b) => {
                const chain = String(a.chain).localeCompare(String(b.chain));
                const actor = String(a.actor).localeCompare(String(b.actor));
                const permission = String(a.permission).localeCompare(String(b.permission));
                return chain || actor || permission;
            });
            this.storage.write('sessions', JSON.stringify(orderedSessions));
        }
        else {
            this.storage.write('sessions', JSON.stringify([serialized]));
        }
    }
    async getSessions() {
        if (!this.storage) {
            throw new Error('No storage instance is available to retrieve sessions from.');
        }
        const data = await this.storage.read('sessions');
        if (!data)
            return [];
        try {
            const parsed = JSON.parse(data);
            const filtered = parsed.filter((s) => this.walletPlugins.some((p) => {
                return p.id === s.walletPlugin.id;
            }));
            return filtered;
        }
        catch (e) {
            throw new Error(`Failed to parse sessions from storage (${e})`);
        }
    }
    getSessionOptions(options) {
        return {
            abis: this.abis,
            allowModify: this.allowModify,
            appName: this.appName,
            expireSeconds: this.expireSeconds,
            fetch: this.fetch,
            storage: this.storage,
            transactPlugins: options?.transactPlugins || this.transactPlugins,
            transactPluginsOptions: options?.transactPluginsOptions || this.transactPluginsOptions,
            ui: this.ui,
        };
    }
}

class AbstractUserInterface {
    translate(key, options, namespace) {
        throw new Error('The `translate` method must be implemented in this UserInterface. Called with: ' +
            JSON.stringify({
                key,
                options,
                namespace,
            }));
    }
    getTranslate(namespace) {
        return (key, options) => this.translate(key, options, namespace);
    }
    addTranslations(translations) {
        throw new Error('The `addTranslations` method must be implemented in this UserInterface. Called with: ' +
            JSON.stringify(translations));
    }
}

export { AbstractLoginPlugin, AbstractTransactPlugin, AbstractUserInterface, AbstractWalletPlugin, BaseLoginPlugin, BaseTransactPlugin, BrowserLocalStorage, LoginContext, LoginHookTypes, Session, SessionKit, TransactContext, TransactHookTypes, TransactRevisions, WalletPluginMetadata, appendAction, SessionKit as default, getFetch, prependAction };
//# sourceMappingURL=session.m.js.map
